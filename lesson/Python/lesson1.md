# Лекция 1

**Приведение типов, Типы данных-Списки/кортежи/множества/словари, Циклы, Исключения, Функции, Генераторы**

*19.08.2025 кол-во часов занятия: `0.5`(Повторение Enternet c 12:30до 13:00) + Python `0.5`(с13:00до13:40)*

*21.08.2025 кол-во часов занятия:`3`(с12:20до15:14)*

*23.08.2025 кол-во часов занятия:`1.5`(с12:04до13:23)*

## Приведение типов

Процесс преобразования данных одного типа в другой называется **Преобразование типов**

В`Python` есть 2 типа преобразования типов:

1. Неявное преобразование - автоматическое преобразование типов.
2. Явное преобразование - преобразование типов в ручную.

### Преобразование неявного типа

В определённых ситуациях `Python` автоматически преобразует один тип данных в другой.

````python
int_number = 15
float_number = 0.123

summa = int_number + float_number

print(summa, type(summa))
````

```cmd
summa: 15.123, type: <class "float">
```

Таким образом конечным результатом будет число тип которого `float`.

*Замечание:* Если мы сложим типы `str` и `int` то получим ошибку `TypeError`, если не использовать явное преобразование.

### Преобразование явного типа

При явном преобразовании типов пользователь преобразуют тип данных объекта в требуемый тип данных.

Для явного преобразования используют встроенные функции `str(), int(), float(), bool()` и т.д

Данный тип называют *привидением типов*, т.к пользователь меняет(*приводит*) тип данных объекта

```python
num_string = '12'
num_int = 34
print('1', type(num_string))

num_string = int(num_string)
summa = num_int + num_string
print('2', summa, type(summa))
```

```cmd
'1' <class 'str'>
'2' 46, <class 'int'>
```

### Итог:

1. Преобразование типов - это преобразование данных из одного типа в другой
2. Неявное преобразование выполняется автоматически интерпретатором Python
3. Python позволяет избежать потери данных при неявном преобразовании
4. Приведение типов - преобразования типов данных объектов с помощью определённых пользователем функций.
5. При приведении типа может быть потеря данных, поскольку мы принудительно преобразуем объект в определённый тип
   данных.

---

## Типы данных

**Хэшируемые объёкты** - Хэш-код представляет собой уникальное число, сгенерированное для создания объекта. Если объект
хэшируемый, то для него всегда генерируется одно и то же число.

*Изменяемые элементы* не являются хэшированными. Для хэширования пользовательских классов нужно реализовать методы
`__hash__` и `__eq__`.

Типы данных делятся на **immutable** и на **mutable**.

**Immutable**(*Неизменяемый*) - значение объекта не изменяется после инициализации.

**Mutable**(*Изменяемый*) - значение может быть изменено.

| Изменяемый | Неизменяемый |
|------------|--------------|
| list       | tuple        |
| set        | frozenset    |
| dict       | int          |
|            | string       |
|            | bool         |
|            | float        |
|            | byte         |

1. **Числа**

*Используются для выполнения математических операций и хранения числовых значений*. В Python 4 типа: int, float, complex
и bool для операций с ними. В Python реализована **длинная арифметика**, поэтому можно не бояться выйти за диапазон.

2. **Строки**

#### String

*Это упорядоченная последовательность символов, заключенная между кавычками, используется для хранения текстовой
информации, а также
имеет множество методов для обработки и манипуляций строками.* К строкам можно обращаться по индексу `s[0], s[-2]`,
поддерживаются срезы, сложение строк, умножение на число.

````python
first_str = 'abcdefg'
print(first_str[0], first_str[::-1], first_str[::2])
str_a = 'a'
print(str_a * 3, first_str + str_a)
````

```cmd
OutPut:
a gfedcba aceg
aaa abcdefga
```

Основные методы строк:

| Метод                      | Что делает                                                         |
|----------------------------|--------------------------------------------------------------------|
| s.find('x',[start], [end]) | Поиск подстроки в строке. Если не найдена подстрока результат `-1` |
| s.format()                 | Форматирование строки( '{}a'.format(1) вернёт 1a)                  |
| s.join([список])           | Собирает строку из списка с разделителем s                         |
| s.replace(x,y)             | Заменяет все вхождения x на y                                      |
| s.strip()                  | Убирает пробелы в начале и в конце строки                          |
| s.split(x)                 | Разбиение строк по разделителю x                                   |

#### Bytes

*Неизменяемая упорядоченная последовательность чисел от 0 до 255*. Создать байт строку можно с помощью `b'123'` или с
помощью применения метода encode() к строке.(*В байтах можно использовать только ASCII символы, либо символы,
закодированные в 16-ричной системе счисления*). Превратить последовательность байт в строку можно с помощью метода
decode() у байт.

3. **Списки и кортежи**

#### List

*Упорядоченная **изменяемая** коллекция объектов произвольных типов*. Создать можно:
`a = list(), a = list('Hello'), a = []`. Поддерживает обращение к элементам по индексам.

Основные методы списков:

| Метод                    | Что делает                                                                                                                   |
|--------------------------|------------------------------------------------------------------------------------------------------------------------------|
| list.append(x)           | Добавляет элемент x в конец списка                                                                                           |
| list.extend(o)           | Расширяет список, добавляя в конец элементы списка o                                                                         |
| list.insert(i,x)         | Вставляет на i-ую позицию элемент x                                                                                          |
| list.remove(x)           | Удаляет первый элемент в списке, имеющий значение x                                                                          |
| list.pop(i)              | Удаляет элемент стоящий на i-ой позиции в списке, с возвращением в качестве результата. Если i не указано, удаляет последний |
| list.count(x)            | Возвращает количество x в списке                                                                                             |
| list.sort([key=функция]) | Сортирует список на основе функции                                                                                           |
| list.reverse()           | Разворачивает список                                                                                                         |
| list.copy()              | Поверхностная копия списка                                                                                                   |
| list.clear()             | Очищение списка                                                                                                              |

#### Tuple

*Кортежи это **неизменяемые** списки*. Создание: `a = tuple(), a = (), a = 12,13 , a = ('s', )`.
**Для чего нужны картежи:**

1. Работа с кортежами быстрее. Если для работы нужно использовать постоянный набор значений, то лучше использовать
   tuple, вместо list
2. Кортежи могут быть ключами словаря, а списки нет.

Кортеж можно преобразовать в список и наоборот. Конструктор tuple воспринимает список как аргумент и возвращает кортеж с
теми же элементами, аналогично для конструктора list().

#### Изменяемый список байт

`b = bytearray(b'abc')`.

4. **Множества**

#### Set

***Изменяемый** тип данных, который хранит не повторяющиеся элементы в случайном порядке*. Создание:
`a = set(), a = (1,2,3,'a'}`

Основные методы множеств:

| Метод        | Что делает                                               |
|--------------|----------------------------------------------------------|
| x.add(a)     | Добавляет элемент в множество                            |
| x.remove(a)  | Удаляет элемент из множества, KeyError если элемента нет |
| x.discard(a) | Удаляет элемент если он есть в множестве                 |
| x.pop()      | Удаляет рандомный элемент в множестве( вообще первый)    |
| x.clear()    | Очистка множества                                        |
| x in s       | Содержится ли x в s                                      |

#### Frozenset

*Единственное отличие от **set** то, что **frozenset** может быть ключом словаря, а **set** нет*

5. **Словари**

*Не упорядоченная коллекция произвольных объектов с доступом по ключу.*  В ключах могут содержаться только хэшируемые
типы данных.

Присваивание по новому ключу расширяет словарь, присваивание по существующему ключу - перезаписывает его, а попытка
извлечь не существующих ключ вызывает исключение `KeyError`.
Создание: `d = {}, d = dict(short = 'hair', long = 'dick'), d = dict([1,2],[3,4])`

Основные методы словарей:

| Метод                          | Что делает                                                                                                                             |
|--------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|
| dict.clear()                   | Очищает словарь                                                                                                                        |
| dict.copy()                    | Возвращает копию словаря                                                                                                               |
| dict.get(key[, default])       | Возвращает значение по ключу, если ключа нет то `default`, если `default` нет то `KeyError`                                            |
| dict.items()                   | Возвращает пары: (ключ, значение)                                                                                                      |
| dict.keys()                    | Возвращает ключи                                                                                                                       |
| dict.pop(key[,default])        | Удаляет ключ и возвращает значение. Если ключа нет то `default`, иначе `KeyError`                                                      |
| dict.popitem()                 | Удаляет и возвращает пару (ключ, значение). Если словарь пуст то `KeyError`. Т.к словари не упорядоченные, то удаляется рандомная пара |
| dict.setdefault(key[,default]) | Возвращает значение по ключу, но если его нет создает ключ со значением `defualt` либо `None`                                          |
| dict.update([other])           | Обновляет словарь добавляя в него пары из `other`. Существующие ключи перезаписываются. Возвращает `None` не новый словарь.            |
| dict.values()                  | Возвращает значение в словаре                                                                                                          |

## Циклы

3 типа циклов: `for`, `if-elif-else`, `while`.

## Функции

**Функция в Python** - это именованный блок кода, который выполняет определённые задачи и может использоваться повторно
в других частях кода. В Python есть *встроенные* функции и *пользовательские*.

### Приемущества функций

**Абстракция** - способ управления сложностью за счет предоставлению пользователю упрощённого интерфейса, при этом
внутренняя работа фрагмента кода остается закрытой или не имеет отношения к контексту использования. Этого можно
добиться, скрыв определённую функциональность внутри функции и предоставив остальной части программы только интерфейс
функции, состоящий из имени и ожидаемых аргументов.

**Инкапсуляция** - объединение данных и функций в единое целое и ограничение прямого доступа к некоторым из этих
компонентов.

Когда мы вызываем функцию Python создает специальное **Пространство имён**(*lesson2*) для этого вызова функции. В этом
пространстве имён будут храниться имена, которые мы определяем внутри функции.

Практический результат такого поведения заключается в том, что переменные, определённые в теле функции, доступны только
внутри самой функции, что позволяет инкапсулировать данные.

**[Модульность](https://realpython.com/defining-your-own-python-function/#modularity)** - принцип проектирования,
согласно которому программа делится на отдельные, независимые и
взаимозаменяемые компоненты. Каждый компонент представляет собой автономную единицу, которая инкапсулирует определенную
часть функциональности программы.

Функции позволяют разделить большую программу, на более мелкие части, выполняющие определённые задачи, что делает код
модульным.

**Тестируемость** - показатель того, насколько легко протестировать фрагмент кода, чтобы убедиться, что он работает
должным образом. Чтобы протестировать код, нужно написать *автоматические тесты*.

Написание функций с понятными названиями переменных и явными возвращаемыми элементами облегчает тестирование кода.

### Функции возвращающие итераторы генератора.

**Итераторы-генераторы** - это объекты, которые позволяют перебирать поток данных или большой набор данных, не сохраняя
весь набор данных в памяти сразу. Вместо этого они выдают элементы по запросу, что позволяет экономить память.

С помощью `yield` можно преобразовать функции в *генератор*.

### Создание замыканий

**[Замыкание](https://realpython.com/python-closure/)** - функция, которая запоминает, получает доступ и использует
переменные из своей внешней функции даже после
выполнения этой внешней функции. То есть, это *внутренняя функция*, которая замыкает на себе переменные, необходимые ей
из внешней функции, сохраняя их для последующего использования.

```python
def func():
    value = 42

    def func1():
        print(f'The value is {value}')

    return func1


number = func()
number()  # Output: The value is 42
```

Замыкания можно использовать для создания *функций с состоянием, обратных вызовов, декараторов, фабричных функций* и
другого.

### Аннотации к функции

**Аннотации к функции** позволяют добавлять метаданные к аргументам и возвращаемому значению функции.

```python

def fucn(array: list, num: int, count: str) -> dict:
    ...
```

Аннотации не накладывают никаких ограничений на код, но данные подсказки полезны.

## [Генераторы](https://realpython.com/introduction-to-python-generators/)

## Исключения

Существует как минимум 2 вида ошибок: синтаксические и исключения.

### Исключения

Ошибки обнаруженные во время выполнения программы называют *исключениями*.

Исключения можно создать с помощью ключевого слова `raise`.

```python
num = 10
if num > 5:
    raise Exception(f'Число не должно быть больше 5. {num =}')
print(num)
```

Программа останавливается и выводит исключение в терминал. (*Важно, что последний `print` не вывелся, т.к Python выдал
исключение до того, как добрался до этой строчки кода*)

```cmd
 File "C:\Users\ateev\PycharmProjects\PythonProject\lesson\Python\lesson1.py", line 20, in <module>
    raise Exception(f'Число не должно быть больше 5. {num = }')
Exception: Число не должно быть больше 5. num = 10
```

С помощью `raise` можно вызвать любой объект исключения в Python и остановить программу при возникновении
неблагоприятного условия.

### Отладка во время разработки с помощью `assert`.

Есть особый тип исключений, который следует использовать только при отладке программы во время разработки. Это
исключения - `AssertionError` - его не следует вызывать самостоятельно с помощью `raise`. Для этого нужно использовать
`assert`

Идея `assert` в том, что программа должна запускаться только при соблюдении определённых условий. Если Python проверяет
утверждение и результат **True**, то программа можно продолжить выполнение, иначе будет сгенерировано исключение
*AssertionError* и программа сразу остановится.

```python
num = 10
assert (num > 5), 'Число не должно превышать 5'

print(num)
```

```cmd
    assert num < 5, 'Число не должно превышать 5'
           ^^^^^^^
AssertionError: Число не должно превышать 5
```

### Обработка ошибок

Для обработки ошибок в Python используют структуру `try-except-finally`

```python
try:
    '''
    Здесь код, который может вызвать ошибку
    '''
    raise TypeError('TypeError')
except(TypeError, KeyError) as err:
    '''
    Код в блоке выполняется, если тип исключения совпадает с одни из типов (TypeError, KeyError и остальных указанных в expect.
    Полученное исключение доступно в необязательной Переменной
    
    Если не указать определённый тип исключения то except перехватывает все виды исключений(Лучше такое не использовать)
    '''
else:
    '''
    Данный блок кода позволяет указать программе, что должно быть выполнено только при отсутствие исключений.
    '''
finally:
    '''
    Блок кода, который будет выполнен в любом случае.
    '''
```

**Важно**: Если мы обрабатываем несколько определённых исключений, то их порядок неважен, т.к Python создает исключения
первым. Как только Python создаст исключения, он проверяет `except` блоки сверху донизу и выполняет первое подходящее
исключение, которое встретит.


### Создание пользовательских исключений.

Для создания собственного исключения, нужно создать класс, наследуемый от класса `Exception`.

```python
class GoshaError(Exception):
    """
    Реализация ошибки
    """
    def __init__(self, message):
        self.message = message
    def __str__(self):
        return self.message

    raise 'Error message'
```

[встроенные исключения в Python.](https://www.programiz.com/python-programming/exceptions)

**Иерархия исключений**
```txt
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```